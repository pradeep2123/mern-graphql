{"version":3,"sources":["../../src/plugins/PgRecordFunctionConnectionPlugin.js"],"names":["base64","str","Buffer","from","String","toString","PgRecordFunctionConnectionPlugin","builder","pgForbidSetofFunctionsToReturnNull","hook","_","build","newWithHooks","getSafeAliasFromResolveInfo","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLList","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","procedure","forEach","proc","returnsSet","namespace","returnTypeId","NodeType","recordFunctionReturnType","Error","name","EdgeType","recordFunctionEdge","description","fields","fieldWithHooks","cursor","addDataGenerator","usesCursor","type","resolve","data","JSON","stringify","__cursor","isCursorField","node","_args","_context","resolveInfo","safeAlias","__origin","isEdgeType","nodeType","pgIntrospection","recordFunctionConnection","nodes","map","entry","edges","hoistCursor","isConnectionType","edgeType"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nexport default (function PgRecordFunctionConnectionPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false }\n) {\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        newWithHooks,\n        getSafeAliasFromResolveInfo,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        graphql: { GraphQLObjectType, GraphQLNonNull, GraphQLList },\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const nullableIf = (condition, Type) =>\n        condition ? Type : new GraphQLNonNull(Type);\n      const Cursor = getTypeByName(\"Cursor\");\n\n      introspectionResultsByKind.procedure.forEach(proc => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!proc.returnsSet) return;\n        if (!proc.namespace) return;\n        if (omit(proc, \"execute\")) return;\n\n        if (proc.returnTypeId !== \"2249\") {\n          // Does not return a record type; defer handling to\n          // PgTablesPlugin and PgScalarFunctionConnectionPlugin\n          return;\n        }\n        // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod\n        // on function arguments and return types, however maybe a later\n        // version of PG will?\n        const NodeType = getTypeByName(\n          inflection.recordFunctionReturnType(proc)\n        );\n        if (!NodeType) {\n          throw new Error(\n            `Do not have a node type '${inflection.recordFunctionReturnType(\n              proc\n            )}' for '${proc.name}' so cannot create connection type`\n          );\n        }\n        const EdgeType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.recordFunctionEdge(proc),\n            description: `A \\`${NodeType.name}\\` edge in the connection.`,\n            fields: ({ fieldWithHooks }) => {\n              return {\n                cursor: fieldWithHooks(\n                  \"cursor\",\n                  ({ addDataGenerator }) => {\n                    addDataGenerator(() => ({\n                      usesCursor: [true],\n                    }));\n                    return {\n                      description: \"A cursor for use in pagination.\",\n                      type: Cursor,\n                      resolve(data) {\n                        return base64(JSON.stringify(data.__cursor));\n                      },\n                    };\n                  },\n                  {\n                    isCursorField: true,\n                  }\n                ),\n                node: pgField(\n                  build,\n                  fieldWithHooks,\n                  \"node\",\n                  {\n                    description: `The \\`${NodeType.name}\\` at the end of the edge.`,\n                    type: nullableIf(\n                      !pgForbidSetofFunctionsToReturnNull,\n                      NodeType\n                    ),\n                    resolve(data, _args, _context, resolveInfo) {\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      return data[safeAlias];\n                    },\n                  },\n                  {},\n                  false\n                ),\n              };\n            },\n          },\n          {\n            __origin: `Adding function result edge type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isEdgeType: true,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n\n        /*const ConnectionType = */\n        newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.recordFunctionConnection(proc),\n            description: `A connection to a list of \\`${NodeType.name}\\` values.`,\n            fields: ({ fieldWithHooks }) => {\n              return {\n                nodes: pgField(build, fieldWithHooks, \"nodes\", {\n                  description: `A list of \\`${NodeType.name}\\` objects.`,\n                  type: new GraphQLNonNull(\n                    new GraphQLList(\n                      nullableIf(!pgForbidSetofFunctionsToReturnNull, NodeType)\n                    )\n                  ),\n                  resolve(data, _args, _context, resolveInfo) {\n                    const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n                    return data.data.map(entry => entry[safeAlias]);\n                  },\n                }),\n                edges: pgField(\n                  build,\n                  fieldWithHooks,\n                  \"edges\",\n                  {\n                    description: `A list of edges which contains the \\`${NodeType.name}\\` and cursor to aid in pagination.`,\n                    type: new GraphQLNonNull(\n                      new GraphQLList(new GraphQLNonNull(EdgeType))\n                    ),\n                    resolve(data, _args, _context, resolveInfo) {\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      return data.data.map(entry => ({\n                        __cursor: entry.__cursor,\n                        ...entry[safeAlias],\n                      }));\n                    },\n                  },\n                  {},\n                  false,\n                  {\n                    hoistCursor: true,\n                  }\n                ),\n              };\n            },\n          },\n          {\n            __origin: `Adding function connection type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isConnectionType: true,\n            edgeType: EdgeType,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n      });\n      return _;\n    },\n    [\"PgRecordFunctionConnection\"]\n  );\n}: Plugin);\n"],"file":"PgRecordFunctionConnectionPlugin.js"}