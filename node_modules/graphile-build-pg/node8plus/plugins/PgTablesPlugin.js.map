{"version":3,"sources":["../../src/plugins/PgTablesPlugin.js"],"names":["base64","str","Buffer","from","String","toString","hasNonNullKey","row","Array","isArray","__identifiers","every","i","k","Object","prototype","hasOwnProperty","call","PgTablesPlugin","builder","pgForbidSetofFunctionsToReturnNull","subscriptions","handleNullRow","_identifiers","identifiers","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","getSafeAliasFromResolveInfo","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","inflection","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","class","forEach","table","tablePgType","type","Error","arrayTablePgType","arrayType","primaryKeyConstraint","primaryKeys","keyAttributes","attributes","tableTypeName","tableType","shouldHaveNodeId","isSelectable","namespace","length","TableType","TablePatchType","TableBaseInputType","id","cb","description","name","interfaces","builtin","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","selectIdentifiers","resolve","data","finalIdentifiers","map","identifier","idx","key","domainBaseType","int","parseInt","Number","MAX_SAFE_INTEGER","__origin","pgIntrospection","isPgRowType","isPgCompoundType","isPgCompositeType","pgCreateInputFields","pgPatchInputFields","pgBaseInputFields","inputType","isInputType","pgAddSubfield","fieldName","attrName","pgType","spec","typeModifier","patchType","isPgPatch","baseInputType","isPgBaseInput","unmap","obj","modifier","fieldLookup","attr2sql","attr","column","inputField","v","fragment","namespaceName","null","join","EdgeType","edge","fieldWithHooks","cursor","addDataGenerator","usesCursor","__cursor","JSON","stringify","isCursorField","node","_args","resolveContext","resolveInfo","safeAlias","record","liveRecord","rootValue","withQueryBuilder","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","recurseDataGeneratorsForField","nodes","entry","edges","_context","hoistCursor","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","_set","RelevantTableInputType"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nconst hasNonNullKey = row => {\n  if (\n    Array.isArray(row.__identifiers) &&\n    row.__identifiers.every(i => i != null)\n  ) {\n    return true;\n  }\n  for (const k in row) {\n    if (Object.prototype.hasOwnProperty.call(row, k)) {\n      if ((k[0] !== \"_\" || k[1] !== \"_\") && row[k] !== null) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport default (function PgTablesPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false, subscriptions = false }\n) {\n  const handleNullRow = pgForbidSetofFunctionsToReturnNull\n    ? (row, _identifiers) => row\n    : (row, identifiers) => {\n        if ((identifiers && hasNonNullKey(identifiers)) || hasNonNullKey(row)) {\n          return row;\n        } else {\n          return null;\n        }\n      };\n\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        getNodeIdForTypeAndIdentifiers,\n        nodeIdFieldName,\n        newWithHooks,\n        getSafeAliasFromResolveInfo,\n        pgSql: sql,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgRegisterGqlTypeByTypeId,\n        pgRegisterGqlInputTypeByTypeId,\n        pg2GqlMapper,\n        gql2pg,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLNonNull,\n          GraphQLID,\n          GraphQLList,\n          GraphQLInputObjectType,\n        },\n        inflection,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const nullableIf = (condition, Type) =>\n        condition ? Type : new GraphQLNonNull(Type);\n      const Cursor = getTypeByName(\"Cursor\");\n\n      introspectionResultsByKind.class.forEach(table => {\n        const tablePgType = table.type;\n        if (!tablePgType) {\n          throw new Error(\"Could not determine the type for this table\");\n        }\n        const arrayTablePgType = tablePgType.arrayType;\n        const primaryKeyConstraint = table.primaryKeyConstraint;\n        const primaryKeys =\n          primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n        const attributes = table.attributes;\n        const tableTypeName = inflection.tableType(table);\n        const shouldHaveNodeId: boolean =\n          nodeIdFieldName &&\n          table.isSelectable &&\n          table.namespace &&\n          primaryKeys &&\n          primaryKeys.length\n            ? true\n            : false;\n        let TableType;\n        let TablePatchType;\n        let TableBaseInputType;\n        pgRegisterGqlTypeByTypeId(\n          tablePgType.id,\n          cb => {\n            if (TableType) {\n              return TableType;\n            }\n            if (pg2GqlMapper[tablePgType.id]) {\n              // Already handled\n              throw new Error(\n                `Register was called but there's already a mapper in place for '${tablePgType.id}'!`\n              );\n            }\n            TableType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: table.description || tablePgType.description,\n                name: tableTypeName,\n                interfaces: () => {\n                  if (shouldHaveNodeId) {\n                    return [getTypeByName(inflection.builtin(\"Node\"))];\n                  } else {\n                    return [];\n                  }\n                },\n                fields: ({ addDataGeneratorForField, Self }) => {\n                  const fields = {};\n                  if (shouldHaveNodeId) {\n                    // Enable nodeId interface\n                    addDataGeneratorForField(nodeIdFieldName, () => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.selectIdentifiers(table);\n                        },\n                      };\n                    });\n                    fields[nodeIdFieldName] = {\n                      description:\n                        \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                      type: new GraphQLNonNull(GraphQLID),\n                      resolve(data) {\n                        const identifiers = data.__identifiers;\n                        if (!identifiers) {\n                          return null;\n                        }\n                        /*\n                         * For bigint we want NodeIDs to be the same as int up\n                         * to the limits of int, and only to be strings after\n                         * that point.\n                         */\n                        const finalIdentifiers = identifiers.map(\n                          (identifier, idx) => {\n                            const key = primaryKeys[idx];\n                            const type = key.type.domainBaseType || key.type;\n                            if (type.id === \"20\" /* bigint */) {\n                              /*\n                               * When migrating from 'int' to 'bigint' we want\n                               * to maintain nodeIDs in the safe range before\n                               * moving to strings for larger numbers. Since we\n                               * can represent ints up to MAX_SAFE_INTEGER\n                               * (2^53 - 1) fine, we're using that as the\n                               * boundary.\n                               */\n                              const int = parseInt(identifier, 10);\n                              if (\n                                int >= -Number.MAX_SAFE_INTEGER &&\n                                int <= Number.MAX_SAFE_INTEGER\n                              ) {\n                                return int;\n                              }\n                            }\n                            return identifier;\n                          }\n                        );\n                        return getNodeIdForTypeAndIdentifiers(\n                          Self,\n                          ...finalIdentifiers\n                        );\n                      },\n                    };\n                  }\n                  return fields;\n                },\n              },\n              {\n                __origin: `Adding table type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable, // TODO:v5: remove - typo\n                isPgCompositeType: !table.isSelectable,\n              }\n            );\n            cb(TableType);\n            const pgCreateInputFields = {};\n            const pgPatchInputFields = {};\n            const pgBaseInputFields = {};\n            newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `An input for mutations affecting \\`${tableTypeName}\\``,\n                name: inflection.inputType(TableType),\n              },\n              {\n                __origin: `Adding table input type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isInputType: true,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgCreateInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              },\n              true // If no fields, skip type automatically\n            );\n\n            if (table.isSelectable) {\n              // XXX: these don't belong here; but we have to keep them here\n              // because third-party code depends on `getTypeByName` to find\n              // them; so we have to register them ahead of time. A better\n              // approach is to use the modifier to specify the type you need,\n              // 'patch' or 'base', so they can be registered just in time.\n              TablePatchType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                  name: inflection.patchType(TableType),\n                },\n                {\n                  __origin: `Adding table patch type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgPatch: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgPatchInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                },\n                true // Safe to skip this if no fields support updating\n              );\n              TableBaseInputType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: `An input representation of \\`${tableTypeName}\\` with nullable fields.`,\n                  name: inflection.baseInputType(TableType),\n                },\n                {\n                  __origin: `Adding table base input type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgBaseInput: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgBaseInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                }\n              );\n            }\n\n            pg2GqlMapper[tablePgType.id] = {\n              map: _ => _,\n              unmap: (obj, modifier) => {\n                let fieldLookup;\n                if (modifier === \"patch\") {\n                  fieldLookup = pgPatchInputFields;\n                } else if (modifier === \"base\") {\n                  fieldLookup = pgBaseInputFields;\n                } else {\n                  fieldLookup = pgCreateInputFields;\n                }\n\n                const attr2sql = attr => {\n                  // TODO: this should use `fieldInput[*].name` to find the attribute\n                  const fieldName = inflection.column(attr);\n                  const inputField = fieldLookup[fieldName];\n                  const v = obj[fieldName];\n                  if (inputField && v != null) {\n                    const { type, typeModifier } = inputField;\n                    return sql.fragment`${gql2pg(\n                      v,\n                      type,\n                      typeModifier\n                    )}::${sql.identifier(type.namespaceName, type.name)}`;\n                  } else {\n                    return sql.null; // TODO: return default instead.\n                  }\n                };\n\n                return sql.fragment`row(${sql.join(\n                  attributes.map(attr2sql),\n                  \",\"\n                )})::${sql.identifier(\n                  tablePgType.namespaceName,\n                  tablePgType.name\n                )}`;\n              },\n            };\n\n            const EdgeType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: `A \\`${tableTypeName}\\` edge in the connection.`,\n                name: inflection.edge(TableType.name),\n                fields: ({ fieldWithHooks }) => {\n                  return {\n                    cursor: fieldWithHooks(\n                      \"cursor\",\n                      ({ addDataGenerator }) => {\n                        addDataGenerator(() => ({\n                          usesCursor: [true],\n                          pgQuery: queryBuilder => {\n                            if (primaryKeys) {\n                              queryBuilder.selectIdentifiers(table);\n                            }\n                          },\n                        }));\n                        return {\n                          description: \"A cursor for use in pagination.\",\n                          type: Cursor,\n                          resolve(data) {\n                            return (\n                              data.__cursor &&\n                              base64(JSON.stringify(data.__cursor))\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isCursorField: true,\n                      }\n                    ),\n                    node: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"node\",\n                      {\n                        description: `The \\`${tableTypeName}\\` at the end of the edge.`,\n                        type: nullableIf(\n                          !pgForbidSetofFunctionsToReturnNull,\n                          TableType\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const record = handleNullRow(\n                            data[safeAlias],\n                            data.__identifiers\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          if (\n                            record &&\n                            primaryKeys &&\n                            liveRecord &&\n                            data.__identifiers\n                          ) {\n                            liveRecord(\"pg\", table, data.__identifiers);\n                          }\n                          return record;\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                  };\n                },\n              },\n              {\n                __origin: `Adding table edge type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isEdgeType: true,\n                isPgRowEdgeType: true,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n            const PageInfo = getTypeByName(inflection.builtin(\"PageInfo\"));\n\n            /*const ConnectionType = */\n            newWithHooks(\n              GraphQLObjectType,\n              {\n                description: `A connection to a list of \\`${tableTypeName}\\` values.`,\n                name: inflection.connection(TableType.name),\n                fields: ({ recurseDataGeneratorsForField, fieldWithHooks }) => {\n                  recurseDataGeneratorsForField(\"pageInfo\", true);\n                  return {\n                    nodes: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"nodes\",\n                      {\n                        description: `A list of \\`${tableTypeName}\\` objects.`,\n                        type: new GraphQLNonNull(\n                          new GraphQLList(\n                            nullableIf(\n                              !pgForbidSetofFunctionsToReturnNull,\n                              TableType\n                            )\n                          )\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          return data.data.map(entry => {\n                            const record = handleNullRow(\n                              entry[safeAlias],\n                              entry[safeAlias].__identifiers\n                            );\n                            if (\n                              record &&\n                              liveRecord &&\n                              primaryKeys &&\n                              entry[safeAlias].__identifiers\n                            ) {\n                              liveRecord(\n                                \"pg\",\n                                table,\n                                entry[safeAlias].__identifiers\n                              );\n                            }\n\n                            return record;\n                          });\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                    edges: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"edges\",\n                      {\n                        description: `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                        type: new GraphQLNonNull(\n                          new GraphQLList(new GraphQLNonNull(EdgeType))\n                        ),\n                        resolve(data, _args, _context, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          return data.data.map(entry => ({\n                            ...entry,\n                            ...entry[safeAlias],\n                          }));\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        hoistCursor: true,\n                      }\n                    ),\n                    pageInfo: PageInfo && {\n                      description: \"Information to aid in pagination.\",\n                      type: new GraphQLNonNull(PageInfo),\n                      resolve(data) {\n                        return data;\n                      },\n                    },\n                  };\n                },\n              },\n              {\n                __origin: `Adding table connection type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isConnectionType: true,\n                isPgRowConnectionType: true,\n                edgeType: EdgeType,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          tablePgType.id,\n          (_set, modifier) => {\n            // This must come first, it triggers creation of all the types\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              tablePgType.id,\n              null\n            );\n            // This must come after the pgGetGqlTypeByTypeIdAndModifier call\n            if (modifier === \"patch\") {\n              // TODO: v5: move the definition from above down here\n              return TablePatchType;\n            }\n            if (modifier === \"base\") {\n              // TODO: v5: move the definition from above down here\n              return TableBaseInputType;\n            }\n            if (TableType) {\n              return getTypeByName(inflection.inputType(TableType));\n            }\n            return null;\n          },\n          true\n        );\n\n        if (arrayTablePgType) {\n          // Note: these do not return\n          //\n          // `new GraphQLList(new GraphQLNonNull(...))`\n          //\n          // because it's possible to return null entries from postgresql\n          // functions. We should probably add a flag to instead export\n          // the non-null version as that's more typical.\n          pgRegisterGqlTypeByTypeId(\n            arrayTablePgType.id,\n            () => {\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                tablePgType.id,\n                null\n              );\n              return new GraphQLList(TableType);\n            },\n            true\n          );\n          pgRegisterGqlInputTypeByTypeId(\n            arrayTablePgType.id,\n            (_set, modifier) => {\n              const RelevantTableInputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                tablePgType.id,\n                modifier\n              );\n              if (RelevantTableInputType) {\n                return new GraphQLList(RelevantTableInputType);\n              }\n            },\n            true\n          );\n        }\n      });\n      return _;\n    },\n    [\"PgTables\"],\n    [],\n    [\"PgTypes\"]\n  );\n}: Plugin);\n"],"file":"PgTablesPlugin.js"}