{"version":3,"sources":["../../src/plugins/PgScalarFunctionConnectionPlugin.js"],"names":["base64","str","Buffer","from","String","toString","PgScalarFunctionConnectionPlugin","builder","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLList","GraphQLString","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","pgField","Cursor","procedure","forEach","proc","returnsSet","namespace","returnType","typeById","returnTypeId","returnTypeTable","classById","classId","id","NodeType","EdgeType","name","scalarFunctionEdge","description","fields","fieldWithHooks","cursor","addDataGenerator","usesCursor","type","resolve","data","JSON","stringify","__cursor","isCursorField","node","value","__origin","isEdgeType","nodeType","pgIntrospection","scalarFunctionConnection","nodes","map","entry","edges","hoistCursor","isConnectionType","edgeType"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nexport default (function PgScalarFunctionConnectionPlugin(builder) {\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        newWithHooks,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLNonNull,\n          GraphQLList,\n          GraphQLString,\n        },\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const Cursor = getTypeByName(\"Cursor\");\n      introspectionResultsByKind.procedure.forEach(proc => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!proc.returnsSet) return;\n        if (!proc.namespace) return;\n        if (omit(proc, \"execute\")) return;\n\n        const returnType =\n          introspectionResultsByKind.typeById[proc.returnTypeId];\n        const returnTypeTable =\n          introspectionResultsByKind.classById[returnType.classId];\n        if (returnTypeTable) {\n          // Just use the standard table connection from PgTablesPlugin\n          return;\n        }\n        if (returnType.id === \"2249\") {\n          // Defer handling to PgRecordFunctionConnectionPlugin\n          return;\n        }\n        // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod\n        // on function arguments and return types, however maybe a later\n        // version of PG will?\n        const NodeType =\n          pgGetGqlTypeByTypeIdAndModifier(returnType.id, null) || GraphQLString;\n        const EdgeType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.scalarFunctionEdge(proc),\n            description: `A \\`${NodeType.name}\\` edge in the connection.`,\n            fields: ({ fieldWithHooks }) => {\n              return {\n                cursor: fieldWithHooks(\n                  \"cursor\",\n                  ({ addDataGenerator }) => {\n                    addDataGenerator(() => ({\n                      usesCursor: [true],\n                    }));\n                    return {\n                      description: \"A cursor for use in pagination.\",\n                      type: Cursor,\n                      resolve(data) {\n                        return base64(JSON.stringify(data.__cursor));\n                      },\n                    };\n                  },\n                  {\n                    isCursorField: true,\n                  }\n                ),\n                node: {\n                  description: `The \\`${NodeType.name}\\` at the end of the edge.`,\n                  type: NodeType,\n                  resolve(data) {\n                    return data.value;\n                  },\n                },\n              };\n            },\n          },\n          {\n            __origin: `Adding function result edge type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isEdgeType: true,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n\n        /*const ConnectionType = */\n        newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.scalarFunctionConnection(proc),\n            description: `A connection to a list of \\`${NodeType.name}\\` values.`,\n            fields: ({ fieldWithHooks }) => {\n              return {\n                nodes: pgField(build, fieldWithHooks, \"nodes\", {\n                  description: `A list of \\`${NodeType.name}\\` objects.`,\n                  type: new GraphQLNonNull(new GraphQLList(NodeType)),\n                  resolve(data) {\n                    return data.data.map(entry => entry.value);\n                  },\n                }),\n                edges: pgField(\n                  build,\n                  fieldWithHooks,\n                  \"edges\",\n                  {\n                    description: `A list of edges which contains the \\`${NodeType.name}\\` and cursor to aid in pagination.`,\n                    type: new GraphQLNonNull(\n                      new GraphQLList(new GraphQLNonNull(EdgeType))\n                    ),\n                    resolve(data) {\n                      return data.data;\n                    },\n                  },\n                  {},\n                  false,\n                  {\n                    hoistCursor: true,\n                  }\n                ),\n              };\n            },\n          },\n          {\n            __origin: `Adding function connection type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isConnectionType: true,\n            edgeType: EdgeType,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n      });\n      return _;\n    },\n    [\"PgScalarFunctionConnection\"],\n    [],\n    [\"PgTypes\"]\n  );\n}: Plugin);\n"],"file":"PgScalarFunctionConnectionPlugin.js"}