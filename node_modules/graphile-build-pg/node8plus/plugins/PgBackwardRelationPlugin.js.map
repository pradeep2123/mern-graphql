{"version":3,"sources":["../../src/plugins/PgBackwardRelationPlugin.js"],"names":["debug","OMIT","DEPRECATED","ONLY","PgBackwardRelationPlugin","builder","pgLegacyRelations","pgSimpleCollections","subscriptions","legacyRelationMode","only","deprecated","hook","fields","build","context","extend","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","graphql","GraphQLNonNull","GraphQLList","inflection","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgOmit","omit","sqlCommentByAddingTags","describePgEntity","scope","isPgRowType","pgIntrospection","foreignTable","fieldWithHooks","Self","kind","foreignKeyConstraints","foreignConstraints","filter","con","type","foreignTableTypeName","tableType","gqlForeignTableType","id","reduce","memo","constraint","table","classById","classId","isSelectable","tableTypeName","gqlTableType","Error","name","schema","namespace","keys","keyAttributes","foreignKeys","foreignKeyAttributes","every","_","some","key","isUnique","constraints","find","c","keyAttributeNums","length","n","i","num","isDeprecated","singleRelationFieldName","singleRelationByKeysBackwards","primaryKeyConstraint","primaryKeys","shouldAddSingleRelation","shouldAddManyRelation","getDataFromParsedResolveInfoFragment","addDataGenerator","sqlFrom","identifier","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","tableAlias","Symbol","foreignTableAlias","getTableAlias","query","useAsterisk","asJson","addNullCase","withPagination","innerQueryBuilder","parentQueryBuilder","selectIdentifiers","forEach","where","fragment","rootValue","alias","description","tags","backwardDescription","args","resolve","data","_args","resolveContext","resolveInfo","safeAlias","record","liveRecord","__identifiers","pgFieldIntrospection","isPgBackwardSingleRelationField","foreignSingleFieldName","makeFields","isConnection","manyRelationFieldName","manyRelationByKeys","manyRelationByKeysSimple","queryOptions","canUseAsterisk","withPaginationAsFields","asJsonAggregate","ConnectionType","TableType","makeLiveCollection","addLiveCondition","beforeLock","isOrderUnique","cursorPrefix","orderBy","setOrderIsUnique","connection","liveCollection","liveConditions","__live","__id","rest","condition","checker","records","r","deprecationReason","isPgFieldConnection","isPgFieldSimpleCollection","isPgBackwardRelationField","simpleCollections","hasConnections","hasSimpleCollections"],"mappings":";;;;;;;AACA;;;;AAIA,MAAMA,KAAK,GAAG,oBAAa,mBAAb,CAAd;AAEA,MAAMC,IAAI,GAAG,CAAb;AACA,MAAMC,UAAU,GAAG,CAAnB;AACA,MAAMC,IAAI,GAAG,CAAb;;IAEyBC,wB,GAAT,SAASA,wBAAT,CACdC,OADc,EAEd;AAAEC,EAAAA,iBAAF;AAAqBC,EAAAA,mBAArB;AAA0CC,EAAAA;AAA1C,CAFc,EAGd;AACA,QAAMC,kBAAkB,GACtB;AACEC,IAAAA,IAAI,EAAEP,IADR;AAEEQ,IAAAA,UAAU,EAAET;AAFd,IAGEI,iBAHF,KAGwBL,IAJ1B;AAKAI,EAAAA,OAAO,CAACO,IAAR,CACE,0BADF,EAEE,CAACC,MAAD,EAASC,KAAT,EAAgBC,OAAhB,KAA4B;AAC1B,UAAM;AACJC,MAAAA,MADI;AAEJC,MAAAA,aAFI;AAGJC,MAAAA,+BAHI;AAIJC,MAAAA,4BAA4B,EAAEC,0BAJ1B;AAKJC,MAAAA,KAAK,EAAEC,GALH;AAMJC,MAAAA,2BANI;AAOJC,MAAAA,qBAPI;AAQJC,MAAAA,OAAO,EAAE;AAAEC,QAAAA,cAAF;AAAkBC,QAAAA;AAAlB,OARL;AASJC,MAAAA,UATI;AAUJC,MAAAA,sBAAsB,EAAEC,oBAVpB;AAWJC,MAAAA,mBAAmB,EAAEC,iBAXjB;AAYJC,MAAAA,MAAM,EAAEC,IAZJ;AAaJC,MAAAA,sBAbI;AAcJC,MAAAA;AAdI,QAeFtB,KAfJ;AAgBA,UAAM;AACJuB,MAAAA,KAAK,EAAE;AAAEC,QAAAA,WAAF;AAAeC,QAAAA,eAAe,EAAEC;AAAhC,OADH;AAEJC,MAAAA,cAFI;AAGJC,MAAAA;AAHI,QAIF3B,OAJJ;;AAKA,QAAI,CAACuB,WAAD,IAAgB,CAACE,YAAjB,IAAiCA,YAAY,CAACG,IAAb,KAAsB,OAA3D,EAAoE;AAClE,aAAO9B,MAAP;AACD,KAxByB,CAyB1B;;;AACA,UAAM+B,qBAAqB,GAAGJ,YAAY,CAACK,kBAAb,CAAgCC,MAAhC,CAC5BC,GAAG,IAAIA,GAAG,CAACC,IAAJ,KAAa,GADQ,CAA9B;AAGA,UAAMC,oBAAoB,GAAGrB,UAAU,CAACsB,SAAX,CAAqBV,YAArB,CAA7B;AACA,UAAMW,mBAAmB,GAAGjC,+BAA+B,CACzDsB,YAAY,CAACQ,IAAb,CAAkBI,EADuC,EAEzD,IAFyD,CAA3D;;AAIA,QAAI,CAACD,mBAAL,EAA0B;AACxBnD,MAAAA,KAAK,CACF,sDAAqDwC,YAAY,CAACQ,IAAb,CAAkBI,EAAG,EADxE,CAAL;AAGA,aAAOvC,MAAP;AACD;;AAED,WAAOG,MAAM,CACXH,MADW,EAEX+B,qBAAqB,CAACS,MAAtB,CAA6B,CAACC,IAAD,EAAOC,UAAP,KAAsB;AACjD,UAAIrB,IAAI,CAACqB,UAAD,EAAa,MAAb,CAAR,EAA8B;AAC5B,eAAOD,IAAP;AACD;;AACD,YAAME,KAAK,GACTpC,0BAA0B,CAACqC,SAA3B,CAAqCF,UAAU,CAACG,OAAhD,CADF;;AAEA,UAAI,CAACF,KAAK,CAACG,YAAX,EAAyB;AACvB;AACA,eAAOL,IAAP;AACD;;AACD,YAAMM,aAAa,GAAGhC,UAAU,CAACsB,SAAX,CAAqBM,KAArB,CAAtB;AACA,YAAMK,YAAY,GAAG3C,+BAA+B,CAClDsC,KAAK,CAACR,IAAN,CAAWI,EADuC,EAElD,IAFkD,CAApD;;AAIA,UAAI,CAACS,YAAL,EAAmB;AACjB7D,QAAAA,KAAK,CACF,8CAA6CuD,UAAU,CAACG,OAAQ,EAD9D,CAAL;AAGA,eAAOJ,IAAP;AACD;;AACD,UAAI,CAACE,KAAL,EAAY;AACV,cAAM,IAAIM,KAAJ,CACH,4DAA2DP,UAAU,CAACQ,IAAK,GADxE,CAAN;AAGD;;AACD,YAAMC,MAAM,GAAGR,KAAK,CAACS,SAArB;AAEA,YAAMC,IAAI,GAAGX,UAAU,CAACY,aAAxB;AACA,YAAMC,WAAW,GAAGb,UAAU,CAACc,oBAA/B;;AACA,UAAI,CAACH,IAAI,CAACI,KAAL,CAAWC,CAAC,IAAIA,CAAhB,CAAD,IAAuB,CAACH,WAAW,CAACE,KAAZ,CAAkBC,CAAC,IAAIA,CAAvB,CAA5B,EAAuD;AACrD,cAAM,IAAIT,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACD,UAAII,IAAI,CAACM,IAAL,CAAUC,GAAG,IAAIvC,IAAI,CAACuC,GAAD,EAAM,MAAN,CAArB,CAAJ,EAAyC;AACvC,eAAOnB,IAAP;AACD;;AACD,UAAIc,WAAW,CAACI,IAAZ,CAAiBC,GAAG,IAAIvC,IAAI,CAACuC,GAAD,EAAM,MAAN,CAA5B,CAAJ,EAAgD;AAC9C,eAAOnB,IAAP;AACD;;AACD,YAAMoB,QAAQ,GAAG,CAAC,CAAClB,KAAK,CAACmB,WAAN,CAAkBC,IAAlB,CACjBC,CAAC,IACC,CAACA,CAAC,CAAC7B,IAAF,KAAW,GAAX,IAAkB6B,CAAC,CAAC7B,IAAF,KAAW,GAA9B,KACA6B,CAAC,CAACC,gBAAF,CAAmBC,MAAnB,KAA8Bb,IAAI,CAACa,MADnC,IAEAF,CAAC,CAACC,gBAAF,CAAmBR,KAAnB,CAAyB,CAACU,CAAD,EAAIC,CAAJ,KAAUf,IAAI,CAACe,CAAD,CAAJ,CAAQC,GAAR,KAAgBF,CAAnD,CAJe,CAAnB;AAOA,YAAMG,YAAY,GAAGT,QAAQ,IAAIjE,kBAAkB,KAAKP,UAAxD;AAEA,YAAMkF,uBAAuB,GAAGV,QAAQ,GACpC9C,UAAU,CAACyD,6BAAX,CACEnB,IADF,EAEEV,KAFF,EAGEhB,YAHF,EAIEe,UAJF,CADoC,GAOpC,IAPJ;AASA,YAAM+B,oBAAoB,GAAG9B,KAAK,CAAC8B,oBAAnC;AACA,YAAMC,WAAW,GACfD,oBAAoB,IAAIA,oBAAoB,CAACnB,aAD/C;AAGA,YAAMqB,uBAAuB,GAC3Bd,QAAQ,IAAIjE,kBAAkB,KAAKN,IADrC;AAGA,YAAMsF,qBAAqB,GACzB,CAACf,QAAD,IACAjE,kBAAkB,KAAKP,UADvB,IAEAO,kBAAkB,KAAKN,IAHzB;;AAKA,UACEqF,uBAAuB,IACvB,CAACtD,IAAI,CAACsB,KAAD,EAAQ,MAAR,CADL,IAEA4B,uBAHF,EAIE;AACA9B,QAAAA,IAAI,GAAGtC,MAAM,CACXsC,IADW,EAEX;AACE,WAAC8B,uBAAD,GAA2B3C,cAAc,CACvC2C,uBADuC,EAEvC,CAAC;AACCM,YAAAA,oCADD;AAECC,YAAAA;AAFD,WAAD,KAGM;AACJ,kBAAMC,OAAO,GAAGtE,GAAG,CAACuE,UAAJ,CAAe7B,MAAM,CAACD,IAAtB,EAA4BP,KAAK,CAACO,IAAlC,CAAhB;AACA4B,YAAAA,gBAAgB,CAACG,yBAAyB,IAAI;AAC5C,qBAAO;AACLC,gBAAAA,OAAO,EAAEC,YAAY,IAAI;AACvBA,kBAAAA,YAAY,CAACC,MAAb,CAAoB,MAAM;AACxB,0BAAMC,WAAW,GAAGR,oCAAoC,CACtDI,yBADsD,EAEtDjC,YAFsD,CAAxD;AAIA,0BAAMsC,UAAU,GAAG7E,GAAG,CAACuE,UAAJ,CAAeO,MAAM,EAArB,CAAnB;AACA,0BAAMC,iBAAiB,GAAGL,YAAY,CAACM,aAAb,EAA1B;AACA,0BAAMC,KAAK,GAAGzE,oBAAoB,CAChC8D,OADgC,EAEhCO,UAFgC,EAGhCD,WAHgC,EAIhC;AACEM,sBAAAA,WAAW,EAAE,KADf;AACsB;AACpBC,sBAAAA,MAAM,EAAE,IAFV;AAGEC,sBAAAA,WAAW,EAAE,IAHf;AAIEC,sBAAAA,cAAc,EAAE;AAJlB,qBAJgC,EAUhCC,iBAAiB,IAAI;AACnBA,sBAAAA,iBAAiB,CAACC,kBAAlB,GAAuCb,YAAvC;;AACA,0BACExF,aAAa,IACbgD,KAAK,CAAC8B,oBAFR,EAGE;AACAsB,wBAAAA,iBAAiB,CAACE,iBAAlB,CAAoCtD,KAApC;AACD;;AACDU,sBAAAA,IAAI,CAAC6C,OAAL,CAAa,CAACtC,GAAD,EAAMQ,CAAN,KAAY;AACvB2B,wBAAAA,iBAAiB,CAACI,KAAlB,CACE1F,GAAG,CAAC2F,QAAS,GAAEd,UAAW,IAAG7E,GAAG,CAACuE,UAAJ,CAC3BpB,GAAG,CAACV,IADuB,CAE3B,MAAKsC,iBAAkB,IAAG/E,GAAG,CAACuE,UAAJ,CAC1BzB,WAAW,CAACa,CAAD,CAAX,CAAelB,IADW,CAE1B,EALJ;AAOD,uBARD;AASD,qBA3B+B,EA4BhCiC,YAAY,CAACjF,OA5BmB,EA6BhCiF,YAAY,CAACkB,SA7BmB,CAAlC;AA+BA,2BAAO5F,GAAG,CAAC2F,QAAS,IAAGV,KAAM,GAA7B;AACD,mBAvCD,EAuCG/E,qBAAqB,CAACsE,yBAAyB,CAACqB,KAA3B,CAvCxB;AAwCD;AA1CI,eAAP;AA4CD,aA7Ce,CAAhB;AA8CA,mBAAO;AACLC,cAAAA,WAAW,EACT7D,UAAU,CAAC8D,IAAX,CAAgBC,mBAAhB,IACC,oBAAmB1D,aAAc,gCAA+BX,oBAAqB,KAHnF;AAILD,cAAAA,IAAI,EAAEa,YAJD;AAKL0D,cAAAA,IAAI,EAAE,EALD;AAMLC,cAAAA,OAAO,EAAE,CAACC,IAAD,EAAOC,KAAP,EAAcC,cAAd,EAA8BC,WAA9B,KAA8C;AACrD,sBAAMC,SAAS,GAAGtG,2BAA2B,CAC3CqG,WAD2C,CAA7C;AAGA,sBAAME,MAAM,GAAGL,IAAI,CAACI,SAAD,CAAnB;AACA,sBAAME,UAAU,GACdH,WAAW,CAACV,SAAZ,IACAU,WAAW,CAACV,SAAZ,CAAsBa,UAFxB;;AAGA,oBAAID,MAAM,IAAIC,UAAd,EAA0B;AACxBA,kBAAAA,UAAU,CAAC,IAAD,EAAOvE,KAAP,EAAcsE,MAAM,CAACE,aAArB,CAAV;AACD;;AACD,uBAAOF,MAAP;AACD;AAlBI,aAAP;AAoBD,WAzEsC,EA0EvC;AACEG,YAAAA,oBAAoB,EAAEzE,KADxB;AAEE0E,YAAAA,+BAA+B,EAAE;AAFnC,WA1EuC;AAD3C,SAFW,EAmFV,kCAAiC9F,gBAAgB,CAChDmB,UADgD,CAEhD,0DAAyDpB,sBAAsB,CAC/EoB,UAD+E,EAE/E;AACE4E,UAAAA,sBAAsB,EAAE;AAD1B,SAF+E,CAK/E,EA1FS,CAAb;AA4FD;;AACD,eAASC,UAAT,CAAoBC,YAApB,EAAkC;AAChC,YAAI3D,QAAQ,IAAI,CAAC2D,YAAjB,EAA+B;AAC7B;AACA;AACD;;AACD,YAAI5C,qBAAqB,IAAI,CAACvD,IAAI,CAACsB,KAAD,EAAQ,MAAR,CAAlC,EAAmD;AACjD,gBAAM8E,qBAAqB,GAAGD,YAAY,GACtCzG,UAAU,CAAC2G,kBAAX,CACErE,IADF,EAEEV,KAFF,EAGEhB,YAHF,EAIEe,UAJF,CADsC,GAOtC3B,UAAU,CAAC4G,wBAAX,CACEtE,IADF,EAEEV,KAFF,EAGEhB,YAHF,EAIEe,UAJF,CAPJ;AAcAD,UAAAA,IAAI,GAAGtC,MAAM,CACXsC,IADW,EAEX;AACE,aAACgF,qBAAD,GAAyB7F,cAAc,CACrC6F,qBADqC,EAErC,CAAC;AACC5C,cAAAA,oCADD;AAECC,cAAAA;AAFD,aAAD,KAGM;AACJ,oBAAMC,OAAO,GAAGtE,GAAG,CAACuE,UAAJ,CAAe7B,MAAM,CAACD,IAAtB,EAA4BP,KAAK,CAACO,IAAlC,CAAhB;AACA,oBAAM0E,YAAY,GAAG;AACnBjC,gBAAAA,WAAW,EAAEhD,KAAK,CAACkF,cADA;AAEnB/B,gBAAAA,cAAc,EAAE0B,YAFG;AAGnBM,gBAAAA,sBAAsB,EAAE,KAHL;AAInBC,gBAAAA,eAAe,EAAE,CAACP;AAJC,eAArB;AAMA1C,cAAAA,gBAAgB,CAACG,yBAAyB,IAAI;AAC5C,uBAAO;AACLC,kBAAAA,OAAO,EAAEC,YAAY,IAAI;AACvBA,oBAAAA,YAAY,CAACC,MAAb,CAAoB,MAAM;AACxB,4BAAMC,WAAW,GAAGR,oCAAoC,CACtDI,yBADsD,EAEtDuC,YAAY,GAAGQ,cAAH,GAAoBC,SAFsB,CAAxD;AAIA,4BAAM3C,UAAU,GAAG7E,GAAG,CAACuE,UAAJ,CAAeO,MAAM,EAArB,CAAnB;AACA,4BAAMC,iBAAiB,GAAGL,YAAY,CAACM,aAAb,EAA1B;AACA,4BAAMC,KAAK,GAAGzE,oBAAoB,CAChC8D,OADgC,EAEhCO,UAFgC,EAGhCD,WAHgC,EAIhCuC,YAJgC,EAKhC7B,iBAAiB,IAAI;AACnBA,wBAAAA,iBAAiB,CAACC,kBAAlB,GAAuCb,YAAvC;;AACA,4BAAIxF,aAAJ,EAAmB;AACjBoG,0BAAAA,iBAAiB,CAACmC,kBAAlB,CAAqCvF,KAArC;AACAoD,0BAAAA,iBAAiB,CAACoC,gBAAlB,CACEvB,IAAI,IAAIK,MAAM,IAAI;AAChB,mCAAO5D,IAAI,CAACI,KAAL,CACLG,GAAG,IACDqD,MAAM,CAACrD,GAAG,CAACV,IAAL,CAAN,KAAqB0D,IAAI,CAAChD,GAAG,CAACV,IAAL,CAFtB,CAAP;AAID,2BANH,EAOEG,IAAI,CAACb,MAAL,CAAY,CAACC,IAAD,EAAOmB,GAAP,EAAYQ,CAAZ,KAAkB;AAC5B3B,4BAAAA,IAAI,CACFmB,GAAG,CAACV,IADF,CAAJ,GAEIzC,GAAG,CAAC2F,QAAS,GAAEZ,iBAAkB,IAAG/E,GAAG,CAACuE,UAAJ,CACtCzB,WAAW,CAACa,CAAD,CAAX,CAAelB,IADuB,CAEtC,EAJF;AAKA,mCAAOT,IAAP;AACD,2BAPD,EAOG,EAPH,CAPF;AAgBD;;AACD,4BAAIiC,WAAJ,EAAiB;AACf,8BACE/E,aAAa,IACb,CAAC6H,YADD,IAEA7E,KAAK,CAAC8B,oBAHR,EAIE;AACAsB,4BAAAA,iBAAiB,CAACE,iBAAlB,CACEtD,KADF;AAGD;;AACDoD,0BAAAA,iBAAiB,CAACqC,UAAlB,CACE,SADF,EAEE,MAAM;AACJ;AACA,gCACE,CAACrC,iBAAiB,CAACsC,aAAlB,CACC,KADD,CADH,EAIE;AACAtC,8BAAAA,iBAAiB,CAACa,IAAlB,CAAuB0B,YAAvB,GAAsC,CACpC,iBADoC,CAAtC;AAGA5D,8BAAAA,WAAW,CAACwB,OAAZ,CAAoBtC,GAAG,IAAI;AACzBmC,gCAAAA,iBAAiB,CAACwC,OAAlB,CACE9H,GAAG,CAAC2F,QAAS,GAAEL,iBAAiB,CAACN,aAAlB,EAAkC,IAAGhF,GAAG,CAACuE,UAAJ,CAClDpB,GAAG,CAACV,IAD8C,CAElD,EAHJ,EAIE,IAJF;AAMD,+BAPD;AAQA6C,8BAAAA,iBAAiB,CAACyC,gBAAlB;AACD;AACF,2BAtBH;AAwBD;;AAEDnF,wBAAAA,IAAI,CAAC6C,OAAL,CAAa,CAACtC,GAAD,EAAMQ,CAAN,KAAY;AACvB2B,0BAAAA,iBAAiB,CAACI,KAAlB,CACE1F,GAAG,CAAC2F,QAAS,GAAEd,UAAW,IAAG7E,GAAG,CAACuE,UAAJ,CAC3BpB,GAAG,CAACV,IADuB,CAE3B,MAAKsC,iBAAkB,IAAG/E,GAAG,CAACuE,UAAJ,CAC1BzB,WAAW,CAACa,CAAD,CAAX,CAAelB,IADW,CAE1B,EALJ;AAOD,yBARD;AASD,uBAvE+B,EAwEhCiC,YAAY,CAACjF,OAxEmB,EAyEhCiF,YAAY,CAACkB,SAzEmB,CAAlC;AA2EA,6BAAO5F,GAAG,CAAC2F,QAAS,IAAGV,KAAM,GAA7B;AACD,qBAnFD,EAmFG/E,qBAAqB,CAACsE,yBAAyB,CAACqB,KAA3B,CAnFxB;AAoFD;AAtFI,iBAAP;AAwFD,eAzFe,CAAhB;AA0FA,oBAAM0B,cAAc,GAAG5H,aAAa,CAClCW,UAAU,CAAC0H,UAAX,CAAsBzF,YAAY,CAACE,IAAnC,CADkC,CAApC;AAGA,oBAAM+E,SAAS,GAAG5H,+BAA+B,CAC/CsC,KAAK,CAACR,IAAN,CAAWI,EADoC,EAE/C,IAF+C,CAAjD;AAIA,qBAAO;AACLgE,gBAAAA,WAAW,EACT7D,UAAU,CAAC8D,IAAX,CAAgBC,mBAAhB,IACC,mDAAkD1D,aAAc,KAH9D;AAILZ,gBAAAA,IAAI,EAAEqF,YAAY,GACd,IAAI3G,cAAJ,CAAmBmH,cAAnB,CADc,GAEd,IAAInH,cAAJ,CACE,IAAIC,WAAJ,CAAgB,IAAID,cAAJ,CAAmBoH,SAAnB,CAAhB,CADF,CANC;AASLvB,gBAAAA,IAAI,EAAE,EATD;AAULC,gBAAAA,OAAO,EAAE,CAACC,IAAD,EAAOC,KAAP,EAAcC,cAAd,EAA8BC,WAA9B,KAA8C;AACrD,wBAAMC,SAAS,GAAGtG,2BAA2B,CAC3CqG,WAD2C,CAA7C;AAGA,wBAAM2B,cAAc,GAClB3B,WAAW,CAACV,SAAZ,IACAU,WAAW,CAACV,SAAZ,CAAsBqC,cAFxB;AAGA,wBAAMC,cAAc,GAClB5B,WAAW,CAACV,SAAZ,IACAU,WAAW,CAACV,SAAZ,CAAsBsC,cAFxB;;AAGA,sBACEhJ,aAAa,IACb+I,cADA,IAEAC,cAFA,IAGA/B,IAAI,CAACgC,MAJP,EAKE;AACA,0BAAM;AAAEC,sBAAAA,IAAF;AAAQ,yBAAGC;AAAX,wBAAoBlC,IAAI,CAACgC,MAA/B;AACA,0BAAMG,SAAS,GAAGJ,cAAc,CAACE,IAAD,CAAhC;AACA,0BAAMG,OAAO,GAAGD,SAAS,CAACD,IAAD,CAAzB;AAEAJ,oBAAAA,cAAc,CAAC,IAAD,EAAO/F,KAAP,EAAcqG,OAAd,CAAd;AACD;;AACD,sBAAIxB,YAAJ,EAAkB;AAChB,2BAAOrG,iBAAiB,CAACyF,IAAI,CAACI,SAAD,CAAL,CAAxB;AACD,mBAFD,MAEO;AACL,0BAAMiC,OAAO,GAAGrC,IAAI,CAACI,SAAD,CAApB;AACA,0BAAME,UAAU,GACdH,WAAW,CAACV,SAAZ,IACAU,WAAW,CAACV,SAAZ,CAAsBa,UAFxB;;AAGA,wBAAIxC,WAAW,IAAI/E,aAAf,IAAgCuH,UAApC,EAAgD;AAC9C+B,sBAAAA,OAAO,CAAC/C,OAAR,CACEgD,CAAC,IACCA,CAAC,IACDA,CAAC,CAAC/B,aADF,IAEAD,UAAU,CAAC,IAAD,EAAOvE,KAAP,EAAcuG,CAAC,CAAC/B,aAAhB,CAJd;AAMD;;AACD,2BAAO8B,OAAP;AACD;AACF,iBAjDI;AAkDL,oBAAI3E,YAAY,GACZ;AACE6E,kBAAAA,iBAAiB,EAAE5E,uBAAuB,GACrC,cAAaA,uBAAwB,UADA,GAErC,6BAHP,CAGqC;;AAHrC,iBADY,GAMZ,IANJ;AAlDK,eAAP;AA0DD,aAxKoC,EAyKrC;AACE6E,cAAAA,mBAAmB,EAAE5B,YADvB;AAEE6B,cAAAA,yBAAyB,EAAE,CAAC7B,YAF9B;AAGE8B,cAAAA,yBAAyB,EAAE,IAH7B;AAIElC,cAAAA,oBAAoB,EAAEzE;AAJxB,aAzKqC;AADzC,WAFW,EAqLV,sBACC6E,YAAY,GAAG,YAAH,GAAkB,mBAC/B,SAAQjG,gBAAgB,CACvBmB,UADuB,CAEvB,0DAAyDpB,sBAAsB,CAC/EoB,UAD+E,EAE/E;AACE,aAAC8E,YAAY,GACT,kBADS,GAET,wBAFJ,GAE+B;AAHjC,WAF+E,CAO/E,EAhMS,CAAb;AAkMD;AACF;;AACD,YAAM+B,iBAAiB,GACrB7G,UAAU,CAAC8D,IAAX,CAAgB+C,iBAAhB,IACA5G,KAAK,CAAC6D,IAAN,CAAW+C,iBADX,IAEA7J,mBAHF;AAIA,YAAM8J,cAAc,GAAGD,iBAAiB,KAAK,MAA7C;AACA,YAAME,oBAAoB,GACxBF,iBAAiB,KAAK,MAAtB,IAAgCA,iBAAiB,KAAK,MADxD;;AAEA,UAAIC,cAAJ,EAAoB;AAClBjC,QAAAA,UAAU,CAAC,IAAD,CAAV;AACD;;AACD,UAAIkC,oBAAJ,EAA0B;AACxBlC,QAAAA,UAAU,CAAC,KAAD,CAAV;AACD;;AACD,aAAO9E,IAAP;AACD,KA7YD,EA6YG,EA7YH,CAFW,EAgZV,iCAAgCZ,IAAI,CAACqB,IAAK,EAhZhC,CAAb;AAkZD,GA7bH,EA8bE,CAAC,oBAAD,CA9bF;AAgcD,C","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\n\nimport type { Plugin } from \"graphile-build\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nconst OMIT = 0;\nconst DEPRECATED = 1;\nconst ONLY = 2;\n\nexport default (function PgBackwardRelationPlugin(\n  builder,\n  { pgLegacyRelations, pgSimpleCollections, subscriptions }\n) {\n  const legacyRelationMode =\n    {\n      only: ONLY,\n      deprecated: DEPRECATED,\n    }[pgLegacyRelations] || OMIT;\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        getSafeAliasFromResolveInfo,\n        getSafeAliasFromAlias,\n        graphql: { GraphQLNonNull, GraphQLList },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgAddStartEndCursor: addStartEndCursor,\n        pgOmit: omit,\n        sqlCommentByAddingTags,\n        describePgEntity,\n      } = build;\n      const {\n        scope: { isPgRowType, pgIntrospection: foreignTable },\n        fieldWithHooks,\n        Self,\n      } = context;\n      if (!isPgRowType || !foreignTable || foreignTable.kind !== \"class\") {\n        return fields;\n      }\n      // This is a relation in which WE are foreign\n      const foreignKeyConstraints = foreignTable.foreignConstraints.filter(\n        con => con.type === \"f\"\n      );\n      const foreignTableTypeName = inflection.tableType(foreignTable);\n      const gqlForeignTableType = pgGetGqlTypeByTypeIdAndModifier(\n        foreignTable.type.id,\n        null\n      );\n      if (!gqlForeignTableType) {\n        debug(\n          `Could not determine type for foreign table with id ${foreignTable.type.id}`\n        );\n        return fields;\n      }\n\n      return extend(\n        fields,\n        foreignKeyConstraints.reduce((memo, constraint) => {\n          if (omit(constraint, \"read\")) {\n            return memo;\n          }\n          const table =\n            introspectionResultsByKind.classById[constraint.classId];\n          if (!table.isSelectable) {\n            // Could be a composite type\n            return memo;\n          }\n          const tableTypeName = inflection.tableType(table);\n          const gqlTableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          if (!gqlTableType) {\n            debug(\n              `Could not determine type for table with id ${constraint.classId}`\n            );\n            return memo;\n          }\n          if (!table) {\n            throw new Error(\n              `Could not find the table that referenced us (constraint: ${constraint.name})`\n            );\n          }\n          const schema = table.namespace;\n\n          const keys = constraint.keyAttributes;\n          const foreignKeys = constraint.foreignKeyAttributes;\n          if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n            throw new Error(\"Could not find key columns!\");\n          }\n          if (keys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n          if (foreignKeys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n          const isUnique = !!table.constraints.find(\n            c =>\n              (c.type === \"p\" || c.type === \"u\") &&\n              c.keyAttributeNums.length === keys.length &&\n              c.keyAttributeNums.every((n, i) => keys[i].num === n)\n          );\n\n          const isDeprecated = isUnique && legacyRelationMode === DEPRECATED;\n\n          const singleRelationFieldName = isUnique\n            ? inflection.singleRelationByKeysBackwards(\n                keys,\n                table,\n                foreignTable,\n                constraint\n              )\n            : null;\n\n          const primaryKeyConstraint = table.primaryKeyConstraint;\n          const primaryKeys =\n            primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n\n          const shouldAddSingleRelation =\n            isUnique && legacyRelationMode !== ONLY;\n\n          const shouldAddManyRelation =\n            !isUnique ||\n            legacyRelationMode === DEPRECATED ||\n            legacyRelationMode === ONLY;\n\n          if (\n            shouldAddSingleRelation &&\n            !omit(table, \"read\") &&\n            singleRelationFieldName\n          ) {\n            memo = extend(\n              memo,\n              {\n                [singleRelationFieldName]: fieldWithHooks(\n                  singleRelationFieldName,\n                  ({\n                    getDataFromParsedResolveInfoFragment,\n                    addDataGenerator,\n                  }) => {\n                    const sqlFrom = sql.identifier(schema.name, table.name);\n                    addDataGenerator(parsedResolveInfoFragment => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.select(() => {\n                            const resolveData = getDataFromParsedResolveInfoFragment(\n                              parsedResolveInfoFragment,\n                              gqlTableType\n                            );\n                            const tableAlias = sql.identifier(Symbol());\n                            const foreignTableAlias = queryBuilder.getTableAlias();\n                            const query = queryFromResolveData(\n                              sqlFrom,\n                              tableAlias,\n                              resolveData,\n                              {\n                                useAsterisk: false, // Because it's only a single relation, no need\n                                asJson: true,\n                                addNullCase: true,\n                                withPagination: false,\n                              },\n                              innerQueryBuilder => {\n                                innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                                if (\n                                  subscriptions &&\n                                  table.primaryKeyConstraint\n                                ) {\n                                  innerQueryBuilder.selectIdentifiers(table);\n                                }\n                                keys.forEach((key, i) => {\n                                  innerQueryBuilder.where(\n                                    sql.fragment`${tableAlias}.${sql.identifier(\n                                      key.name\n                                    )} = ${foreignTableAlias}.${sql.identifier(\n                                      foreignKeys[i].name\n                                    )}`\n                                  );\n                                });\n                              },\n                              queryBuilder.context,\n                              queryBuilder.rootValue\n                            );\n                            return sql.fragment`(${query})`;\n                          }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                        },\n                      };\n                    });\n                    return {\n                      description:\n                        constraint.tags.backwardDescription ||\n                        `Reads a single \\`${tableTypeName}\\` that is related to this \\`${foreignTableTypeName}\\`.`,\n                      type: gqlTableType,\n                      args: {},\n                      resolve: (data, _args, resolveContext, resolveInfo) => {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        const record = data[safeAlias];\n                        const liveRecord =\n                          resolveInfo.rootValue &&\n                          resolveInfo.rootValue.liveRecord;\n                        if (record && liveRecord) {\n                          liveRecord(\"pg\", table, record.__identifiers);\n                        }\n                        return record;\n                      },\n                    };\n                  },\n                  {\n                    pgFieldIntrospection: table,\n                    isPgBackwardSingleRelationField: true,\n                  }\n                ),\n              },\n              `Backward relation (single) for ${describePgEntity(\n                constraint\n              )}. To rename this relation with a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                constraint,\n                {\n                  foreignSingleFieldName: \"newNameHere\",\n                }\n              )}`\n            );\n          }\n          function makeFields(isConnection) {\n            if (isUnique && !isConnection) {\n              // Don't need this, use the singular instead\n              return;\n            }\n            if (shouldAddManyRelation && !omit(table, \"many\")) {\n              const manyRelationFieldName = isConnection\n                ? inflection.manyRelationByKeys(\n                    keys,\n                    table,\n                    foreignTable,\n                    constraint\n                  )\n                : inflection.manyRelationByKeysSimple(\n                    keys,\n                    table,\n                    foreignTable,\n                    constraint\n                  );\n\n              memo = extend(\n                memo,\n                {\n                  [manyRelationFieldName]: fieldWithHooks(\n                    manyRelationFieldName,\n                    ({\n                      getDataFromParsedResolveInfoFragment,\n                      addDataGenerator,\n                    }) => {\n                      const sqlFrom = sql.identifier(schema.name, table.name);\n                      const queryOptions = {\n                        useAsterisk: table.canUseAsterisk,\n                        withPagination: isConnection,\n                        withPaginationAsFields: false,\n                        asJsonAggregate: !isConnection,\n                      };\n                      addDataGenerator(parsedResolveInfoFragment => {\n                        return {\n                          pgQuery: queryBuilder => {\n                            queryBuilder.select(() => {\n                              const resolveData = getDataFromParsedResolveInfoFragment(\n                                parsedResolveInfoFragment,\n                                isConnection ? ConnectionType : TableType\n                              );\n                              const tableAlias = sql.identifier(Symbol());\n                              const foreignTableAlias = queryBuilder.getTableAlias();\n                              const query = queryFromResolveData(\n                                sqlFrom,\n                                tableAlias,\n                                resolveData,\n                                queryOptions,\n                                innerQueryBuilder => {\n                                  innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                                  if (subscriptions) {\n                                    innerQueryBuilder.makeLiveCollection(table);\n                                    innerQueryBuilder.addLiveCondition(\n                                      data => record => {\n                                        return keys.every(\n                                          key =>\n                                            record[key.name] === data[key.name]\n                                        );\n                                      },\n                                      keys.reduce((memo, key, i) => {\n                                        memo[\n                                          key.name\n                                        ] = sql.fragment`${foreignTableAlias}.${sql.identifier(\n                                          foreignKeys[i].name\n                                        )}`;\n                                        return memo;\n                                      }, {})\n                                    );\n                                  }\n                                  if (primaryKeys) {\n                                    if (\n                                      subscriptions &&\n                                      !isConnection &&\n                                      table.primaryKeyConstraint\n                                    ) {\n                                      innerQueryBuilder.selectIdentifiers(\n                                        table\n                                      );\n                                    }\n                                    innerQueryBuilder.beforeLock(\n                                      \"orderBy\",\n                                      () => {\n                                        // append order by primary key to the list of orders\n                                        if (\n                                          !innerQueryBuilder.isOrderUnique(\n                                            false\n                                          )\n                                        ) {\n                                          innerQueryBuilder.data.cursorPrefix = [\n                                            \"primary_key_asc\",\n                                          ];\n                                          primaryKeys.forEach(key => {\n                                            innerQueryBuilder.orderBy(\n                                              sql.fragment`${innerQueryBuilder.getTableAlias()}.${sql.identifier(\n                                                key.name\n                                              )}`,\n                                              true\n                                            );\n                                          });\n                                          innerQueryBuilder.setOrderIsUnique();\n                                        }\n                                      }\n                                    );\n                                  }\n\n                                  keys.forEach((key, i) => {\n                                    innerQueryBuilder.where(\n                                      sql.fragment`${tableAlias}.${sql.identifier(\n                                        key.name\n                                      )} = ${foreignTableAlias}.${sql.identifier(\n                                        foreignKeys[i].name\n                                      )}`\n                                    );\n                                  });\n                                },\n                                queryBuilder.context,\n                                queryBuilder.rootValue\n                              );\n                              return sql.fragment`(${query})`;\n                            }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                          },\n                        };\n                      });\n                      const ConnectionType = getTypeByName(\n                        inflection.connection(gqlTableType.name)\n                      );\n                      const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                        table.type.id,\n                        null\n                      );\n                      return {\n                        description:\n                          constraint.tags.backwardDescription ||\n                          `Reads and enables pagination through a set of \\`${tableTypeName}\\`.`,\n                        type: isConnection\n                          ? new GraphQLNonNull(ConnectionType)\n                          : new GraphQLNonNull(\n                              new GraphQLList(new GraphQLNonNull(TableType))\n                            ),\n                        args: {},\n                        resolve: (data, _args, resolveContext, resolveInfo) => {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const liveCollection =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveCollection;\n                          const liveConditions =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveConditions;\n                          if (\n                            subscriptions &&\n                            liveCollection &&\n                            liveConditions &&\n                            data.__live\n                          ) {\n                            const { __id, ...rest } = data.__live;\n                            const condition = liveConditions[__id];\n                            const checker = condition(rest);\n\n                            liveCollection(\"pg\", table, checker);\n                          }\n                          if (isConnection) {\n                            return addStartEndCursor(data[safeAlias]);\n                          } else {\n                            const records = data[safeAlias];\n                            const liveRecord =\n                              resolveInfo.rootValue &&\n                              resolveInfo.rootValue.liveRecord;\n                            if (primaryKeys && subscriptions && liveRecord) {\n                              records.forEach(\n                                r =>\n                                  r &&\n                                  r.__identifiers &&\n                                  liveRecord(\"pg\", table, r.__identifiers)\n                              );\n                            }\n                            return records;\n                          }\n                        },\n                        ...(isDeprecated\n                          ? {\n                              deprecationReason: singleRelationFieldName\n                                ? `Please use ${singleRelationFieldName} instead`\n                                : `Please use singular instead`, // This should never happen\n                            }\n                          : null),\n                      };\n                    },\n                    {\n                      isPgFieldConnection: isConnection,\n                      isPgFieldSimpleCollection: !isConnection,\n                      isPgBackwardRelationField: true,\n                      pgFieldIntrospection: table,\n                    }\n                  ),\n                },\n\n                `Backward relation (${\n                  isConnection ? \"connection\" : \"simple collection\"\n                }) for ${describePgEntity(\n                  constraint\n                )}. To rename this relation with a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  constraint,\n                  {\n                    [isConnection\n                      ? \"foreignFieldName\"\n                      : \"foreignSimpleFieldName\"]: \"newNameHere\",\n                  }\n                )}`\n              );\n            }\n          }\n          const simpleCollections =\n            constraint.tags.simpleCollections ||\n            table.tags.simpleCollections ||\n            pgSimpleCollections;\n          const hasConnections = simpleCollections !== \"only\";\n          const hasSimpleCollections =\n            simpleCollections === \"only\" || simpleCollections === \"both\";\n          if (hasConnections) {\n            makeFields(true);\n          }\n          if (hasSimpleCollections) {\n            makeFields(false);\n          }\n          return memo;\n        }, {}),\n        `Adding backward relations for ${Self.name}`\n      );\n    },\n    [\"PgBackwardRelation\"]\n  );\n}: Plugin);\n"],"file":"PgBackwardRelationPlugin.js"}