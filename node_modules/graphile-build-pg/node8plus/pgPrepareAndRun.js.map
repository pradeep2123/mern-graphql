{"version":3,"sources":["../src/pgPrepareAndRun.js"],"names":["POSTGRAPHILE_PREPARED_STATEMENT_CACHE_SIZE","parseInt","process","env","lastString","lastHash","hash","str","update","digest","pgPrepareAndRun","pgClient","text","values","connection","parsedStatements","query","name","_graphilePreparedStatementCache","LRU","maxLength","dispose","key","escapeIdentifier","then","catch","e","console","error","get","set"],"mappings":";;;;;;;AACA;;AACA;;;;AAGA,MAAMA,0CAA0C,GAC9CC,QAAQ,CAACC,OAAO,CAACC,GAAR,CAAYH,0CAAb,EAAyD,EAAzD,CAAR,IAAwE,GAD1E;AAGA,IAAII,UAAJ;AACA,IAAIC,QAAJ;;AACA,MAAMC,IAAI,GAAIC,GAAD,IAAyB;AACpC,MAAIA,GAAG,KAAKH,UAAZ,EAAwB;AACtBA,IAAAA,UAAU,GAAGG,GAAb;AACAF,IAAAA,QAAQ,GAAG,wBAAW,MAAX,EACRG,MADQ,CACDD,GADC,EAERE,MAFQ,CAED,QAFC,CAAX;AAGD;;AACD,SAAOJ,QAAP;AACD,CARD;;AAUe,SAASK,eAAT,CACbC,QADa,EAEbC,IAFa,EAGb;AACAC,MAJa,EAKb;AACA,QAAMC,UAAU,GAAGH,QAAQ,CAACG,UAA5B;;AACA,MACE,CAACD,MAAD,IACAb,0CAA0C,GAAG,CAD7C,IAEA,CAACc,UAFD,IAGA,CAACA,UAAU,CAACC,gBAJd,EAKE;AACA,WAAOJ,QAAQ,CAACK,KAAT,CAAeJ,IAAf,EAAqBC,MAArB,CAAP;AACD,GAPD,MAOO;AACL,UAAMI,IAAI,GAAGX,IAAI,CAACM,IAAD,CAAjB;;AACA,QAAI,CAACE,UAAU,CAACI,+BAAhB,EAAiD;AAC/CJ,MAAAA,UAAU,CAACI,+BAAX,GAA6C,IAAIC,YAAJ,CAAQ;AACnDC,QAAAA,SAAS,EAAEpB,0CADwC;;AAEnDqB,QAAAA,OAAO,CAACC,GAAD,EAAM;AACX,cAAIR,UAAU,CAACC,gBAAX,CAA4BO,GAA5B,CAAJ,EAAsC;AACpCX,YAAAA,QAAQ,CACLK,KADH,CACU,cAAaL,QAAQ,CAACY,gBAAT,CAA0BD,GAA1B,CAA+B,EADtD,EAEGE,IAFH,CAEQ,MAAM;AACV,qBAAOV,UAAU,CAACC,gBAAX,CAA4BO,GAA5B,CAAP;AACD,aAJH,EAKGG,KALH,CAKSC,CAAC,IAAI;AACV;AACAC,cAAAA,OAAO,CAACC,KAAR,CAAc,gCAAd,EAAgDF,CAAhD;AACD,aARH;AASD;AACF;;AAdkD,OAAR,CAA7C;AAgBD;;AACD,QAAI,CAACZ,UAAU,CAACI,+BAAX,CAA2CW,GAA3C,CAA+CZ,IAA/C,CAAL,EAA2D;AACzD;AACAH,MAAAA,UAAU,CAACI,+BAAX,CAA2CY,GAA3C,CAA+Cb,IAA/C,EAAqD,IAArD;AACD;;AACD,WAAON,QAAQ,CAACK,KAAT,CAAe;AACpBC,MAAAA,IADoB;AAEpBL,MAAAA,IAFoB;AAGpBC,MAAAA;AAHoB,KAAf,CAAP;AAKD;AACF","sourcesContent":["//@flow\nimport { createHash } from \"crypto\";\nimport LRU from \"@graphile/lru\";\nimport type { PoolClient } from \"pg\";\n\nconst POSTGRAPHILE_PREPARED_STATEMENT_CACHE_SIZE =\n  parseInt(process.env.POSTGRAPHILE_PREPARED_STATEMENT_CACHE_SIZE, 10) || 100;\n\nlet lastString: string;\nlet lastHash: string;\nconst hash = (str: string): string => {\n  if (str !== lastString) {\n    lastString = str;\n    lastHash = createHash(\"sha1\")\n      .update(str)\n      .digest(\"base64\");\n  }\n  return lastHash;\n};\n\nexport default function pgPrepareAndRun(\n  pgClient: PoolClient,\n  text: string,\n  // eslint-disable-next-line flowtype/no-weak-types\n  values: any\n) {\n  const connection = pgClient.connection;\n  if (\n    !values ||\n    POSTGRAPHILE_PREPARED_STATEMENT_CACHE_SIZE < 1 ||\n    !connection ||\n    !connection.parsedStatements\n  ) {\n    return pgClient.query(text, values);\n  } else {\n    const name = hash(text);\n    if (!connection._graphilePreparedStatementCache) {\n      connection._graphilePreparedStatementCache = new LRU({\n        maxLength: POSTGRAPHILE_PREPARED_STATEMENT_CACHE_SIZE,\n        dispose(key) {\n          if (connection.parsedStatements[key]) {\n            pgClient\n              .query(`deallocate ${pgClient.escapeIdentifier(key)}`)\n              .then(() => {\n                delete connection.parsedStatements[key];\n              })\n              .catch(e => {\n                // eslint-disable-next-line no-console\n                console.error(\"Error releasing prepared query\", e);\n              });\n          }\n        },\n      });\n    }\n    if (!connection._graphilePreparedStatementCache.get(name)) {\n      // We're relying on dispose to clear out the old ones.\n      connection._graphilePreparedStatementCache.set(name, true);\n    }\n    return pgClient.query({\n      name,\n      text,\n      values,\n    });\n  }\n}\n"],"file":"pgPrepareAndRun.js"}